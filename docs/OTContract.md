# OTContract Summary

This is the superclass for many other classes in Open-Transactions, most notably
`OTMessage` and `OTTransactionType`.

A Contract has

* A type string (usually uppercase). OTContract sets `CONTRACT`.
  subclasses use `MESSAGE`, `LEDGER`, `TRANSACTION`, `TRANSACTION ITEM` and
  maybe others. Written in the content marker (see section Serialization)
* A map of conditions (`string -> string`).
* A map of Nyms (`string -> nym`). Always contains entry _signer_.
* A content section with the serialized XML of the attributes
* A list of signatures

A specification that is compatible with documents written by OTContract
can be found in [SectionFormat.md](../spec/SectionFormat.md).

## Creation

Although `OTContract` is mainly used through subclasses, there are some class
methods for creating a contract (after initializing the class)

* [CreateContract()][CreateContract]

## Serialization

Contracts can be serialized into strings.

The serialization partially defined in the subclasses by the overridden
`CreateContents()` method.

* [RewriteContract()][RewriteContract]
* [CreateContents()][CreateContents]
  -- XML Serialization, defined by subclasses
* [CreateInnerContents()][CreateInnerContents]
  -- XML Serialization of default contract fields, defined by `OTContract`
* [AddBookendsAroundContent()][AddBookendsAroundContent]
  -- Section Serialization

### Sections

The serialization method reads the fields `content`, `contractType`, `hashType`
and `listSignatures` and outputs a string with this structure

```
-----BEGIN SIGNED $type -----
Hash: $hashType
$content
-----BEGIN $type SIGNATURE-----
Version: OpenTransactions [version] // ignored in parsing
Comment: http://github.com/FellowTraveler/Open-Transactions/wiki // also ignored
Meta:    $signatureTag
$signatureData
// other signatures
```

The `$content` field is generated by the XML serialization methods.

### XML Content Section

The outer level of the XML section is written by the subclass. Some of the
inner "default" elements are written when the subclass calls
`OTContract::CreateInnerContents()`.

```xml

<rootElement> <!-- written by subclass -->


<!-- Written by OTContract::CreateInnerContents() -->

<condition name="$name">
    $value
</condition>
<!-- for all conditions -->


<signer hasCredentials="$hasCredentials"
        nymID="$nymId"
        altLocation="$altLocation">

    <nymIDSource>
        $nymIDSource (armored)
    </nymIDSource>

    <credentialList>
        $credentialList (armored)
    </credentialList>

    <credentials>
        $credentialMap (OTDB encoded, armored)
    </credentials>
</signer>


<!-- other XML written by subclass -->

</rootElement>
```

#### Elements
* signer: the Nym doing the signing.
* nymIDSource: the source passed to the 'newnym' command when the Nym was
  created, or the generated public key when nothing was passed.
* credentialList: a list of public credentials if present.
* credentials: TODO figure out what this is.

#### Attributes
* hasCredentials: whether or not the signer has credentials associated with it.
* nymID: the Nym doing the signing.
* altLocation: some optional value passed when creating a Nym.

### Signature Sections

The four-character `Meta` tag is defined as:

* The key type: `E`, `S` or `A` (Encryption, Signing or Authentication)
* First character of the Nym Id
* First character of the Master-Credential Id
* First character of the Sub-Credential Id

This tag aids the signature verification process. If the meta-data doesn't match
the key information gathered from the Nym's sub-credential, the verification
fails.


## Verification

A contract instance can be verified for integrity for an authentic signature
by the `signer` Nym.

Defined by

* [VerifyContract(nym)][VerifyContract]
* [VerifySignature(nym)][VerifySignature]

Contract verification as defined in `VerifyContract()` succeeds if

1. The contract-id field `m_ID` (hash) matches the hash of the trimmed contents
   of `m_strRawFile`.
1. One of the parsed signatures matches one of the _signing_ keys of the
   contract's `signer` Nym.



## Deserialization

Strings can be parsed into instances of `OTContract` and subclasses:

Defined by

* [LoadContract()][LoadContract]
  -- Release, load from disk and call `ParseRawFile()`. Overridden only in
     [Purse](Purse.md), [Mint](Mint.md), and [OTAccount](OTAccount.md).
* [ParseRawFile()][ParseRawFile]
  -- Parse local file into content and signature sections, call
     `LoadContractXML()`.
* [LoadContractXML()][LoadContractXML]
  -- Process XML elements one by one. Calls `ProcessXMLNode()` for each
     element.
* [ProcessXMLNode()][ProcessXMLNode]
  -- Load the contents of an element into class instance fields. Extended by
     almost all subclasses.

A contract can be loaded if:

* It has a content section that contains parsable XML.
* It has at least one signature section that contains a parsable signature.

### Section parsing

Contract documents are parsed line-by-line. Lines that start with a dash (`-`)
have special meaning:

* A line that starts with `---` and has the `BEGIN` keyword marks the beginning
  of the content section, which is given in XML.

* A line that starts with `---` and has the `SIGNATURE` keyword marks a
  signature section, which is ended with a single dash `-`. A contract may
  contain many signatures. For more information on the signature format, see
  [Signatures](#Signatures).

Inside the content section, lines that start with a dash must add a space after
the first dash.

### Values read from XML

The `LoadContractXML()` method parses the XML of the content section and
loads them into fields. If a field cannot be read successfully, the content
section is invalid.

The method loops over all XML elements and calls `ProcessXMLNode()` on each
element. Most subclasses reimplement that method in this fashion:

1. Call `OTContract::ProcessXMLNode()` and see if it is a default element
1. If not, try to process the element in the subclass

See [OTServerContract::ProcessXMLNode()][OTServerContract_ProcessXMLNode] for
example.

The default contract elements recognized by `OTContract::LoadContractXML()` are:

Entity Name | Description
------------|------------
`entity`    | Describes the name and email address of the contract author.
`condition` | Describes the contract condition. A contract can have multiple conditions.
`signer`    | Describes the _signer_ Nym of this contract. The signer must provide a credential list that verifies the Nym.
`key`       | (Deprecated) support for single-key Nym system


In general, later declarations override earlier ones.


# Release Mechanism


Defined by

* [Release()]

## TODO


# Notes

## Serialization

* `CreateInnerContents()` supports the deprecated single-key system.

* The serialization method does not generate the XML required for
  deserialization. The content field is populated by the deriving subclasses.


## Verification

* The integrity check compares the value of class field `m_ID` against the
  calculated hash value of the contract. When is the ID field passed explicitly
  and not derived from the content section of the contract?
* We authenticate against either the `signer` field or the `contract` field that
  is not read during deserialization. I'm guessing that `contract` is
  deprecated.
* The deprecated single-key-system makes an appearance also when loading the
  public keys for signature verification.
* Signature verification takes a `OTPasswordData` argument with unclear purpose.
* The first character of the signature metadata defines the type of key that is
  used. Is there any way that a key that doesn't start with `S` can be valid?


## Deserialization

* The current parser for this document format is too complex and probably has
  some bugs, some of which I document here.
* The content field is marked by the `BEGIN` marker, the signature field by the
  `SIGNATURE` marker. This is an ambiguous rule when it comes to the
  `BEGIN $type SIGNATURE` marker: the first signature section is
  inadvertently recognized as the content section if an explicit content marker
  is missing.
* If the last line of the contract starts a signature section, the process
  terminates: [opentxs#247](https://github.com/Open-Transactions/opentxs/issues/247)
* The `HASH:` field is meant to be read right after the `BEGIN` marker, but can
  in fact be set anywhere: [Link][ProcessHash]. Multiple occurrences are
  possible. This allows the content section to contain lines starting with
  `Hash: ` which will be excluded from the payload, as long as the last
  occurrence is `Hash: samy`. This is an unexpected behavior that makes it
  difficult to determine what is part of a signed message and what is not.
* In the content section, the characters `[dash][space]` (ASCII `0x2d 0x20`) at
  the start of a line should be an escape sequence (see [RFC4880 Section
  7.1](https://tools.ietf.org/html/rfc4880#section-7.1)). The sequence should be
  stripped before adding it to the payload. Instead, the line is added as-is.
  This makes it impossible to provide a signature for a document that has a line
  starting with two dashes (e.g. an embedded Section-Format document).

### XML/Attribute Parser
* XML elements are processed sequentially. Most of the time, a later definition
  of an XML element overrides a previous one (one exception is `m_strName`, for
  instance) This should always be invalid and trigger an error condition.
* Includes support for the deprecated single-key system by recognizing a `key`
  tag.


<!---
Links
-->

[OTContract]: https://github.com/Open-Transactions/opentxs/blob/171bdbdd1327fa016f2043bf43d8662055d263d2/src/core/OTContract.cpp

[LoadContract]: https://github.com/Open-Transactions/opentxs/blob/db31c6aa45bbb773aebbdbd4298acd3755785420/src/core/OTContract.cpp#L1253

[CreateContract]: https://github.com/Open-Transactions/opentxs/blob/db31c6aa45bbb773aebbdbd4298acd3755785420/src/core/OTContract.cpp#L2095

[ParseRawFile]: https://github.com/Open-Transactions/opentxs/blob/db31c6aa45bbb773aebbdbd4298acd3755785420/src/core/OTContract.cpp#L1374

[LoadContractXML]: https://github.com/Open-Transactions/opentxs/blob/db31c6aa45bbb773aebbdbd4298acd3755785420/src/core/OTContract.cpp#L1642

[OTServerContract_ProcessXMLNode]: https://github.com/Open-Transactions/opentxs/blob/5df178684104307d4dc098aacb8c9f9bfb6ca02e/src/core/OTServerContract.cpp#L251

[ProcessXMLNode]: https://github.com/Open-Transactions/opentxs/blob/db31c6aa45bbb773aebbdbd4298acd3755785420/src/core/OTContract.cpp#L2391

[ProcessHash]: https://github.com/Open-Transactions/opentxs/blob/171bdbdd1327fa016f2043bf43d8662055d263d2/src/core/OTContract.cpp#L1575



[RewriteContract]: https://github.com/Open-Transactions/opentxs/blob/171bdbdd1327fa016f2043bf43d8662055d263d2/src/core/OTContract.cpp#L1196

[CreateContents]: https://github.com/Open-Transactions/opentxs/blob/171bdbdd1327fa016f2043bf43d8662055d263d2/src/core/OTContract.cpp#L2384

[CreateInnerContents]: https://github.com/Open-Transactions/opentxs/blob/171bdbdd1327fa016f2043bf43d8662055d263d2/src/core/OTContract.cpp#L2230

[AddBookendsAroundContent]: https://github.com/Open-Transactions/opentxs/blob/171bdbdd1327fa016f2043bf43d8662055d263d2/src/core/OTContract.cpp#L1148



[VerifyContract]: https://github.com/Open-Transactions/opentxs/blob/171bdbdd1327fa016f2043bf43d8662055d263d2/src/core/OTContract.cpp#L330

[VerifySignature]: https://github.com/Open-Transactions/opentxs/blob/171bdbdd1327fa016f2043bf43d8662055d263d2/src/core/OTContract.cpp#L818
